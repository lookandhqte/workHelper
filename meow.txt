refresh действует 3 месяца
access действует 1 сутки


amocrm_golang/
├── cmd/
│   └── app/
│       └── main.go
├── config/
│   ├── config.go
│   └── .env.example
├── internal/
│   ├── app/
│   │   └── app.go
│   │   └── compose.go
│   ├── controller/
│   │   └── http/
│   │       ├── v1/
│   │       │   ├── account_routes.go
│   │       │   ├── contacts_routes.go
│   │       │   ├── dto.go
│   │       │   └── integration_routes.go
│   │       └── router.go
│   ├── entity/
│   │   └── integration_model.go
│   │   └── account_model.go
│   │   └── contact_model.go
│   │   └── contacts_model.go
│   │   └── token_model.go
│   ├── producer/
│   │   └── dto.go
│   │   └── producer.go
│   ├── provider/
│   │   ├── amocrm/
│   │   │  └── dto.go
│   │   │  └── amocrm.go
│   │   ├── unisender/
│   │   │  └── dto.go
│   │   │  └── unisender.go
│   │   └── provider.go
│   ├── usecase/
│   │   ├── account/
│   │   │  └── init.go
│   │   │  └── methods.go
│   │   ├── integration/
│   │   │  └── init.go
│   │   │  └── methods.go
│   │   ├── storage/
│   │   │  └── init.go
│   │   │  └── methods.go
│   │   ├── contacts/
│   │   │  └── init.go
│   │   │  └── methods.go
│   └── repo/
│       ├── persistent/
│       │   ├── database/
│       │     └── storage.go
│       │     └── account.go
│       │     └── integration.go
│       │     └── contacts.go
│       │   ├── inmemory/
│       │     └── storage.go
│       │     └── account.go
│       │     └── integration.go
│       │     └── contacts.go
├── pkg/
│   ├── auth/
│   │   └── jwt.go
│   └── cache/
│       └── cache.go
├── go.mod
├── go.sum
└── .env
└── .gitignore


при редиректе (запрос от виджета) мы добавляем задачу в очередь. 

алгоритм:
handleRedirect:

получить code && client_id
GetTokensByAuthCode
ReturnIntegrations()
for _, integration ... { if integration.ClientID==client_id }
account.Integrations[id].Token = tokens
Update() (account)
GetContacts(tokens)
UpdateAllContacts()
добавить задачу в очередь

очередь наступила:
syncContacts:
PrepareUnisenderContacts() -> GetAllContacts (account)
MakeRouteURL
PrepareRequest
SendRequest
ParseResponse
if ok->for _, contact.. {
contact.status="sync"
}; !ok{
contact.status="failed"
}
UpdateAllContacts(contacts)
c.JSON (status.OK)

снимаем задачу с очереди

алгоритм действий:
перенести handleRedirect в accountRoutes
выбирать первую интеграцию среди интеграций аккаунта, с clientID==resp.clientID
добавить в handleRedirect получение контактов (GetContacts)
убрать роут для получения контактов /:id/contacts
удалить метод getIntegrationByClientID
где он нужен - заменить
добавить Associate(integration) в Update account in DB
создать allContacts сущность
добавить методы allContacts в accountRoute и accountUC (методы GetAllContacts UpdateAllContacts DeleteAllAccountContacts)

добавить перед удалением контактов в БД вызов DeleteAllAccountContacts()
реализовать логику для подготовки пакета контактов (account)
реализовать логику для отправки пакета контактов в Unisender (account)
реализовать логику синхронизации: по новому роуту
(/accounts/:id/contacts/sync):
GetAllAccountsContacts(for every account GetContacts() и UpdateAllContacts)
добавляем в бд если есть новые
подготавливаем пакет контактов
отправляем в Unisender
изменить DELETE /accounts/:id на /accounts/:id/unsubscribe
дописать методы inmemory если есть пустые



дополнительно мысли:
когда очередь наступает получаем все нужные данные в виде кода и клиентИД
после этого мы должны получить токены и присвоить интеграции 
и сразу же получить контакты и присвоить аккаунту
после подготовить контакты для синхронизации с Unisender
получить токен авторизации Unisender
отправить пакетно

тогда будто выгоднее хранить handleRedirect в аккаунтах. и getIntegrationByClientID метод пропадет.